# Задание 11

### 1.Как получить ссылку на текущий поток?
Thread.currentThread()

### 2. Зачем нужно ключевое слово synchronized ? На что его можно вещать(поле, метод, класс, конструктор..) ?
вешается или на метод, или на метод, или на блок кода. Служит для синхронизации по ```монитору```  объекта

### 3. Захват какого монитора происходит при входе в synchronized метод/статик метод/блок ?
метод - this объекта, от которого метод вызван. 

static метод - по классу, которому принадлежит метод

блок - по объекту, который указан в круглых скобках

### 4. Зачем нужно ключевое слово volatile ? На что его можно вещать(поле, метод, класс, конструктор..) ?
Вешается на переменные, чтобы решить 64+битные переменные читались атомарно

### 5. Что делает метод `Object.wait`, `Object.notify`, `Object.notifyAll`
wait - "освобождает" объект, по которому была синхронизация И ставит поток на паузу, давай возможность работать другим потокам
notify/notifyAll - говорят, что можно продолжить работу ( notifyAll сообщает это всем потокам, которые остановились на объекте, а не 1му случайному)

### 6. Что за исключение IllegalMonitorStateException ?
вылетает если вызвать wait на не synchronized объекте

### Что делает метод Thread.join ?
ожидает завершения указанного потока

### Что делает метод Thread,interrupt ? 
поднимает флаг окончания работы потока ( но если поток внутри кода его не проверяет, ничего не будет)


### реализовать ThreadPool

public interface ThreadPool {

    void start(); // запускает потоки. Потоки бездействуют, до тех пор пока не появится новое задание в очереди (см. execute)
    void execute(Runnable runnable); // складывает это задание в очередь. Освободившийся поток должен выполнить это задание. Каждое задание должны быть выполнено ровно 1 раз
}

Сделать 2 реализации ThreadPool
1) FixedThreadPool - Количество потоков задается в конструкторе и не меняется.
2) ScalableThreadPool в конструкторе задается минимальное и максимальное(int min, int max) число потоков,
количество запущенных потоков может быть увеличено от минимального к максимальному, если при добавлении нового задания в очередь нет свободного потока для исполнения этого задания. При отсутствии задания в очереди, количество потоков опять должно быть уменьшено до значения min
